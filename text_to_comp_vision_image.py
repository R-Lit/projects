# -*- coding: utf-8 -*-
"""text to comp vision image.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yHX6L9mUblO-tiw2Q5OqvXfLbfXGkUpK
"""

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image, ImageDraw, ImageFont
import cv2
from scipy import signal
import hashlib

def text_to_image(text, width=512, height=512, visualization_type="spectral"):
    """
    Transform a text string into an image visualization using computer vision principles.

    Args:
        text: Input text string
        width: Width of output image
        height: Height of output image
        visualization_type: Type of visualization (spectral, edges, fourier, hash)

    Returns:
        PIL Image object
    """
    # Generate a base image from text
    img = Image.new('RGB', (width, height), color=(255, 255, 255))
    draw = ImageDraw.Draw(img)

    try:
        # Try to use a nice font if available
        font = ImageFont.truetype("arial.ttf", 12)
    except IOError:
        # Fall back to default font
        font = ImageFont.load_default()

    # Render text onto image (wrapped)
    lines = []
    line = ""
    for word in text.split():
        test_line = line + word + " "
        # Use textlength instead of textsize
        w = draw.textlength(test_line, font=font)
        # Assuming you only need the width for wrapping,
        # you can estimate height or get it from font metrics
        h = font.getsize(test_line)[1]

        if w > width - 20:
            lines.append(line)
            line = word + " "
        else:
            line = test_line
    if line:
        lines.append(line)

    y_pos = 10
    for line in lines:
        draw.text((10, y_pos), line, font=font, fill=(0, 0, 0))
        y_pos += 15
        if y_pos >= height - 15:
            break

    # Convert to numpy array for CV processing
    img_array = np.array(img)

    # Apply different visualizations based on type
    if visualization_type == "spectral":
        # Create a spectral visualization using text characteristics
        # Convert text to numeric values
        text_values = np.array([ord(c) for c in text])

        # Create 2D array from text values (repeat pattern if needed)
        pattern = text_values[:min(len(text_values), width * height)]
        pattern = np.resize(pattern, (height, width))

        # Apply color mapping
        img_vis = cv2.applyColorMap(
            cv2.normalize(pattern, None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8U),
            cv2.COLORMAP_JET
        )

    elif visualization_type == "edges":
        # Convert to grayscale
        gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)

        # Apply edge detection
        edges = cv2.Canny(gray, 50, 150)

        # Create colored edge visualization
        img_vis = np.zeros_like(img_array)

        # Use text hash to determine edge color
        hash_val = int(hashlib.md5(text.encode()).hexdigest(), 16)
        edge_color = [hash_val % 256, (hash_val >> 8) % 256, (hash_val >> 16) % 256]

        img_vis[edges > 0] = edge_color

    elif visualization_type == "fourier":
        # Convert to grayscale
        gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)

        # Compute 2D Fourier transform
        f_transform = np.fft.fft2(gray)
        f_shift = np.fft.fftshift(f_transform)
        magnitude = 20 * np.log(np.abs(f_shift) + 1)

        # Normalize and convert to color
        magnitude = cv2.normalize(magnitude, None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8U)
        img_vis = cv2.applyColorMap(magnitude, cv2.COLORMAP_VIRIDIS)

    elif visualization_type == "hash":
        # Create visualization based on text hash
        hash_obj = hashlib.sha256(text.encode())
        hash_digest = hash_obj.digest()

        # Create a pattern from the hash
        pattern = np.zeros((height, width, 3), dtype=np.uint8)

        # Fill pattern with values derived from hash
        for i in range(min(len(hash_digest) // 3, height)):
            for j in range(width):
                idx = (i * width + j) % (len(hash_digest) - 2)
                pattern[i, j] = [hash_digest[idx], hash_digest[idx + 1], hash_digest[idx + 2]]

        # Apply filters to create interesting patterns
        kernel = np.ones((5, 5), np.float32) / 25
        img_vis = cv2.filter2D(pattern, -1, kernel)

        # Apply wave distortion
        rows, cols = img_vis.shape[:2]
        wave_length = max(5, int(hash_digest[0] / 10))

        for i in range(rows):
            img_vis[i, :] = np.roll(img_vis[i, :], int(10 * np.sin(i / wave_length)), axis=0)

    else:
        # Default to original image
        img_vis = img_array

    # Convert back to PIL image
    return Image.fromarray(img_vis)

def show_text_visualization(text, title=None):
    """Show multiple visualizations of the text"""
    visualization_types = ["spectral", "edges", "fourier", "hash"]

    plt.figure(figsize=(16, 12))

    for i, vis_type in enumerate(visualization_types):
        plt.subplot(2, 2, i + 1)
        img = text_to_image(text, visualization_type=vis_type)
        plt.imshow(np.array(img))
        plt.title(f"{vis_type.capitalize()} Visualization")
        plt.axis('off')

    if title:
        plt.suptitle(title, fontsize=16)
    plt.tight_layout()
    plt.show()

# Example usage
sample_text = """This is a sample text that will be transformed into various
image visualizations using computer vision principles including edge detection,
spectral analysis, Fourier transforms, and hash-based patterns."""

show_text_visualization(sample_text, "Text to Image Visualizations")

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image, ImageDraw, ImageFont
import cv2
from scipy import signal
import hashlib

def text_to_image(text, width=512, height=512, visualization_type="spectral"):
    """
    Transform a text string into an image visualization using computer vision principles.

    Args:
        text: Input text string
        width: Width of output image
        height: Height of output image
        visualization_type: Type of visualization (spectral, edges, fourier, hash)

    Returns:
        PIL Image object
    """
    # Generate a base image from text
    img = Image.new('RGB', (width, height), color=(255, 255, 255))
    draw = ImageDraw.Draw(img)

    try:
        # Try to use a nice font if available
        font = ImageFont.truetype("arial.ttf", 12)
    except IOError:
        # Fall back to default font
        font = ImageFont.load_default()

    # Render text onto image (wrapped)
    lines = []
    line = ""
    for word in text.split():
        test_line = line + word + " "
        # Use textlength instead of textsize
        w = draw.textlength(test_line, font=font)
        # getsize is deprecated and may not be available
        # Use getbbox instead to get the bounding box of the text
        # Assuming you only need the width for wrapping,
        # you can estimate height or get it from font metrics
        # h = font.getsize(test_line)[1]
        # Replace the line above with:
        h = font.getbbox(test_line)[3]  # [3] represents the height in getbbox

        if w > width - 20:
            lines.append(line)
            line = word + " "
        else:
            line = test_line
    if line:
        lines.append(line)

    y_pos = 10
    for line in lines:
        draw.text((10, y_pos), line, font=font, fill=(0, 0, 0))
        y_pos += 15
        if y_pos >= height - 15:
            break

    # Convert to numpy array for CV processing
    img_array = np.array(img)

    # Apply different visualizations based on type
    if visualization_type == "spectral":
        # Create a spectral visualization using text characteristics
        # Convert text to numeric values
        text_values = np.array([ord(c) for c in text])

        # Create 2D array from text values (repeat pattern if needed)
        pattern = text_values[:min(len(text_values), width * height)]
        pattern = np.resize(pattern, (height, width))

        # Apply color mapping
        img_vis = cv2.applyColorMap(
            cv2.normalize(pattern, None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8U),
            cv2.COLORMAP_JET
        )

    elif visualization_type == "edges":
        # Convert to grayscale
        gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)

        # Apply edge detection
        edges = cv2.Canny(gray, 50, 150)

        # Create colored edge visualization
        img_vis = np.zeros_like(img_array)

        # Use text hash to determine edge color
        hash_val = int(hashlib.md5(text.encode()).hexdigest(), 16)
        edge_color = [hash_val % 256, (hash_val >> 8) % 256, (hash_val >> 16) % 256]

        img_vis[edges > 0] = edge_color

    elif visualization_type == "fourier":
        # Convert to grayscale
        gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)

        # Compute 2D Fourier transform
        f_transform = np.fft.fft2(gray)
        f_shift = np.fft.fftshift(f_transform)
        magnitude = 20 * np.log(np.abs(f_shift) + 1)

        # Normalize and convert to color
        magnitude = cv2.normalize(magnitude, None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8U)
        img_vis = cv2.applyColorMap(magnitude, cv2.COLORMAP_VIRIDIS)

    elif visualization_type == "hash":
        # Create visualization based on text hash
        hash_obj = hashlib.sha256(text.encode())
        hash_digest = hash_obj.digest()

        # Create a pattern from the hash
        pattern = np.zeros((height, width, 3), dtype=np.uint8)

        # Fill pattern with values derived from hash
        for i in range(min(len(hash_digest) // 3, height)):
            for j in range(width):
                idx = (i * width + j) % (len(hash_digest) - 2)
                pattern[i, j] = [hash_digest[idx], hash_digest[idx + 1], hash_digest[idx + 2]]

        # Apply filters to create interesting patterns
        kernel = np.ones((5, 5), np.float32) / 25
        img_vis = cv2.filter2D(pattern, -1, kernel)

        # Apply wave distortion
        rows, cols = img_vis.shape[:2]
        wave_length = max(5, int(hash_digest[0] / 10))

        for i in range(rows):
            img_vis[i, :] = np.roll(img_vis[i, :], int(10 * np.sin(i / wave_length)), axis=0)

    else:
        # Default to original image
        img_vis = img_array

    # Convert back to PIL image
    return Image.fromarray(img_vis)

def show_text_visualization(text, title=None):
    """Show multiple visualizations of the text"""
    visualization_types = ["spectral", "edges", "fourier", "hash"]

    plt.figure(figsize=(16, 12))

    for i, vis_type in enumerate(visualization_types):
        plt.subplot(2, 2, i + 1)
        img = text_to_image(text, visualization_type=vis_type)
        plt.imshow(np.array(img))
        plt.title(f"{vis_type.capitalize()} Visualization")
        plt.axis('off')

    if title:
        plt.suptitle(title, fontsize=16)
    plt.tight_layout()
    plt.show()

# Example usage
sample_text = """As already mentioned, these commandments are not the only tactics that the planned change
literature has advocated. But they do provide a useful blueprint for organizations embarking on
change, as well as a way to evaluate a change effort in progress. By going through this list, students
and managers can begin to put together their own strategies for implementing change.
But no list is enough. Implementation is also a process of asking questions like these: Are we
addressing the real needs of the company, or taking the easy way out? How shared is the vision?
How do we preserve anchors to the past while moving to the future? Does everyone need to feel the
same sense of urgency? Can change recipients, particularly those far down in the hierarchy, have an
impact? How do we handle those who oppose the change? When should progress be visible? How
do we integrate special projects to mainstream operations? When is it wise/best to share bad news?
And now that we’ve gotten this far, is this the direction we still want to go?As already mentioned, these commandments are not the only tactics that the planned change
literature has advocated. But they do provide a useful blueprint for organizations embarking on
change, as well as a way to evaluate a change effort in progress. By going through this list, students
and managers can begin to put together their own strategies for implementing change.
But no list is enough. Implementation is also a process of asking questions like these: Are we
addressing the real needs of the company, or taking the easy way out? How shared is the vision?
How do we preserve anchors to the past while moving to the future? Does everyone need to feel the
same sense of urgency? Can change recipients, particularly those far down in the hierarchy, have an
impact? How do we handle those who oppose the change? When should progress be visible? How
do we integrate special projects to mainstream operations? When is it wise/best to share bad news?
And now that we’ve gotten this far, is this the direction we still want to go?As already mentioned, these commandments are not the only tactics that the planned change
literature has advocated. But they do provide a useful blueprint for organizations embarking on
change, as well as a way to evaluate a change effort in progress. By going through this list, students
and managers can begin to put together their own strategies for implementing change.
But no list is enough. Implementation is also a process of asking questions like these: Are we
addressing the real needs of the company, or taking the easy way out? How shared is the vision?
How do we preserve anchors to the past while moving to the future? Does everyone need to feel the
same sense of urgency? Can change recipients, particularly those far down in the hierarchy, have an
impact? How do we handle those who oppose the change? When should progress be visible? How
do we integrate special projects to mainstream operations? When is it wise/best to share bad news?
And now that we’ve gotten this far, is this the direction we still want to go?As already mentioned, these commandments are not the only tactics that the planned change
literature has advocated. But they do provide a useful blueprint for organizations embarking on
change, as well as a way to evaluate a change effort in progress. By going through this list, students
and managers can begin to put together their own strategies for implementing change.
But no list is enough. Implementation is also a process of asking questions like these: Are we
addressing the real needs of the company, or taking the easy way out? How shared is the vision?
How do we preserve anchors to the past while moving to the future? Does everyone need to feel the
same sense of urgency? Can change recipients, particularly those far down in the hierarchy, have an
impact? How do we handle those who oppose the change? When should progress be visible? How
do we integrate special projects to mainstream operations? When is it wise/best to share bad news?
And now that we’ve gotten this far, is this the direction we still want to go?As already mentioned, these commandments are not the only tactics that the planned change
literature has advocated. But they do provide a useful blueprint for organizations embarking on
change, as well as a way to evaluate a change effort in progress. By going through this list, students
and managers can begin to put together their own strategies for implementing change.
But no list is enough. Implementation is also a process of asking questions like these: Are we
addressing the real needs of the company, or taking the easy way out? How shared is the vision?
How do we preserve anchors to the past while moving to the future? Does everyone need to feel the
same sense of urgency? Can change recipients, particularly those far down in the hierarchy, have an
impact? How do we handle those who oppose the change? When should progress be visible? How
do we integrate special projects to mainstream operations? When is it wise/best to share bad news?
And now that we’ve gotten this far, is this the direction we still want to go?As already mentioned, these commandments are not the only tactics that the planned change
literature has advocated. But they do provide a useful blueprint for organizations embarking on
change, as well as a way to evaluate a change effort in progress. By going through this list, students
and managers can begin to put together their own strategies for implementing change.
But no list is enough. Implementation is also a process of asking questions like these: Are we
addressing the real needs of the company, or taking the easy way out? How shared is the vision?
How do we preserve anchors to the past while moving to the future? Does everyone need to feel the
same sense of urgency? Can change recipients, particularly those far down in the hierarchy, have an
impact? How do we handle those who oppose the change? When should progress be visible? How
do we integrate special projects to mainstream operations? When is it wise/best to share bad news?
And now that we’ve gotten this far, is this the direction we still want to go?A already mentioned, these commandments are not the only tactics that the planned change
literature has advocated.asdaklsdmfaksmdflkamsdklfmaklsdfmakdfmalksdfsdfvmsfdskvlfvmsldfmvlsdmlkfvkmsldfkvmsldkfmvlskdmflvkmsdlkfvmksldmfvlkmsdlkfmvlksdmfklvtiowmormvomtiovoismdf;vimgofj;er;otigjw;eorigjweriogjsi;dfviudghubie;rthgwi;reuigwer """

show_text_visualization(sample_text, "Text to Image Visualizations")

