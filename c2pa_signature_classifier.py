# -*- coding: utf-8 -*-
"""C2PA signature classifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HF-8HqPtNzpK294fa5ouA8dpjohmT6Xq
"""

#!/usr/bin/env python3
"""
C2PA Signature Detector for Images
---------------------------------
This script checks whether an uploaded image file contains C2PA (Coalition for Content Provenance and Authenticity)
signatures, which are used for content authentication and can help identify AI-generated content.

Optimized for Google Colab environments.
"""

# prompt: configure file path to /content/ChatGPT Image Apr 1, 2025, 04_53_46 PM.png. and then execute the program on this file and print reuslts

import os
import sys
import subprocess
import json
import tempfile
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, Union
import base64
import re
import io
import warnings

from PIL import Image
import numpy as np
from google.colab import files
import google.colab

# Install c2patool if not present
def install_c2patool():
    """Install the c2patool using cargo (Rust package manager)"""
    try:
        # Check if c2patool is already installed
        result = subprocess.run(["c2patool", "--version"],
                               capture_output=True,
                               check=False)
        if result.returncode == 0:
            print(f"c2patool already installed: {result.stdout.decode().strip()}")
            return True
    except:
        pass

    print("Installing c2patool...")

    # First, check if we're in Colab
    try:
        in_colab = True
    except ImportError:
        in_colab = False

    if in_colab:
        # Install Rust and c2patool in Colab
        try:
            # Install Rust
            subprocess.check_call(["apt-get", "update", "-qq"], stdout=subprocess.DEVNULL)
            subprocess.check_call(["apt-get", "install", "-qq", "build-essential", "curl"], stdout=subprocess.DEVNULL)

            # Create a script to install Rust
            install_script = """
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            source $HOME/.cargo/env
            cargo install c2patool
            """

            with tempfile.NamedTemporaryFile(mode='w', suffix='.sh') as f:
                f.write(install_script)
                f.flush()
                subprocess.check_call(["bash", f.name], stdout=subprocess.DEVNULL)

            # Add cargo bin to PATH
            os.environ["PATH"] = f"{os.environ['HOME']}/.cargo/bin:{os.environ['PATH']}"

            # Verify installation
            result = subprocess.run(["c2patool", "--version"],
                                   capture_output=True,
                                   check=True)
            print(f"c2patool installed: {result.stdout.decode().strip()}")
            return True
        except subprocess.CalledProcessError as e:
            print(f"Failed to install c2patool: {str(e)}")
            return False
    else:
        print("Not in Colab. Please install c2patool manually:")
        print("1. Install Rust: https://www.rust-lang.org/tools/install")
        print("2. Run: cargo install c2patool")
        return False

def format_file_size(size_in_bytes: int) -> str:
    """Format file size to human-readable format."""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_in_bytes < 1024:
            return f"{size_in_bytes:.2f} {unit}"
        size_in_bytes /= 1024
    return f"{size_in_bytes:.2f} PB"


def generate_summary(results: Dict[str, Any]) -> str:
    """Generate a human-readable summary of the analysis results"""
    # ... (rest of the generate_summary function remains unchanged)

# --- Main script ---
file_path = "/content/ChatGPT Image Apr 1, 2025, 04_53_46 PM.png"

if not os.path.exists(file_path):
    print(f"Error: File not found at {file_path}")
else:
    # Placeholder for your image analysis code using c2patool or other library
    # Replace this with your actual analysis logic

    # Example:  (Illustrative - replace with your code)
    try:
        image = Image.open(file_path)
        width, height = image.size
        file_size = os.path.getsize(file_path)

        results = {
            "filename": os.path.basename(file_path),
            "image_info": {"width": width, "height": height},
            "file_size": file_size,
            "c2pa_check": {"has_c2pa": False}, #Example
            "ai_indicators": {"potential_ai_indicators": []} #Example
        }
    except Exception as e:
      print(f"Error processing image: {e}")
      results={}

    summary = generate_summary(results)
print(summary)

#!/usr/bin/env python3
"""
C2PA Signature Detector for Images
---------------------------------
This script checks whether an image file contains C2PA (Coalition for Content Provenance and Authenticity)
signatures, which are used for content authentication and can help identify AI-generated content.
"""

import os
import sys
import subprocess
import json
import tempfile
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, Union
import base64
import re
import io
import warnings

try:
    from PIL import Image
    import numpy as np
    from google.colab import files
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "Pillow", "numpy"])
    from PIL import Image
    import numpy as np
    try:
        from google.colab import files
    except ImportError:
        print("Not running in Google Colab environment")

# Install exiftool if not present
def install_exiftool():
    """Install ExifTool if not already present"""
    try:
        # Check if ExifTool is already available
        subprocess.run(["exiftool", "-ver"], capture_output=True, check=True)
        return True
    except (subprocess.SubprocessError, FileNotFoundError):
        # Check if we're in Google Colab
        try:
            import google.colab
            in_colab = True
        except ImportError:
            in_colab = False

        if in_colab:
            print("Installing ExifTool in Colab environment...")
            try:
                subprocess.check_call(["apt-get", "update", "-qq"])
                subprocess.check_call(["apt-get", "install", "-y", "-qq", "libimage-exiftool-perl"])
                print("ExifTool installed successfully.")
                return True
            except subprocess.SubprocessError as e:
                print(f"Failed to install ExifTool: {e}")
                return False
        else:
            print("ExifTool not found. Please install ExifTool.")
            return False

def check_c2pa_exiftool(image_path: str) -> Dict[str, Any]:
    """Check for C2PA using ExifTool (limited detection)"""
    try:
        # Run exiftool with JSON output, accessing all tags
        result = subprocess.run(
            ["exiftool", "-json", "-a", "-u", "-G3", image_path],
            capture_output=True,
            check=True,
            text=True
        )

        # Parse the JSON output
        metadata = json.loads(result.stdout)[0]

        # Check for C2PA-related fields
        c2pa_info = {
            "has_c2pa": False,
            "c2pa_fields": [],
            "details": {},
            "c2pa_data": {"assertions": []}
        }

        # Look for C2PA/CAI/JUMBF related fields
        c2pa_related_patterns = [
            r'C2PA', r'CAI', r'JUMBF', r'Content.?Credentials',
            r'Manifest', r'Claim', r'Assertions', r'Signature',
            r'OpenAI', r'DALL-E', r'Generated', r'AI'
        ]

        # Flatten metadata for easier searching
        flat_metadata = {}

        def flatten_dict(d, parent_key=''):
            for k, v in d.items():
                new_key = f"{parent_key}.{k}" if parent_key else k
                if isinstance(v, dict):
                    flatten_dict(v, new_key)
                else:
                    flat_metadata[new_key] = v

        flatten_dict(metadata)

        # Look for specific AI generation indicators
        ai_indicators = {
            "ai_generated": None,
            "creation_tool": None,
            "timestamp": None,
            "signature": None
        }

        # Search for specific keys that might indicate AI generation
        for key, value in flat_metadata.items():
            key_lower = key.lower()
            value_str = str(value).lower()

            # Check for AI generation assertion
            if any(term in key_lower for term in ["generative", "ai", "generated", "generator"]):
                ai_indicators["ai_generated"] = value
                c2pa_info["c2pa_data"]["assertions"].append({
                    "label": "generativeai",
                    "data": {"value": value}
                })

            # Check for OpenAI or DALL-E references
            if any(term in key_lower for term in ["creator", "software", "tool"]) or \
               any(term in value_str for term in ["openai", "dall-e", "dalle"]):
                ai_indicators["creation_tool"] = value
                c2pa_info["c2pa_data"]["assertions"].append({
                    "label": "creator",
                    "data": {"value": value}
                })

            # Check for timestamps
            if any(term in key_lower for term in ["date", "time", "created", "timestamp"]):
                # Try to identify actual creation timestamps (not file modified dates)
                if "original" in key_lower or "creation" in key_lower or "created" in key_lower:
                    ai_indicators["timestamp"] = value
                    c2pa_info["c2pa_data"]["assertions"].append({
                        "label": "timestamp",
                        "data": {"value": value}
                    })

            # Check for signature or verification data
            if any(term in key_lower for term in ["signature", "sign", "crypto", "verification", "hash"]):
                ai_indicators["signature"] = True

        # Search for C2PA related patterns
        for key, value in flat_metadata.items():
            for pattern in c2pa_related_patterns:
                if re.search(pattern, key, re.IGNORECASE) or re.search(pattern, str(value), re.IGNORECASE):
                    c2pa_info["has_c2pa"] = True
                    c2pa_info["c2pa_fields"].append(key)
                    c2pa_info["details"][key] = value
                    break

        # Check specifically for XMP C2PA namespace which is a strong indicator
        xmp_keys = [k for k in flat_metadata.keys() if 'XMP' in k]
        for key in xmp_keys:
            if 'c2pa' in key.lower() or 'cai' in key.lower():
                c2pa_info["has_c2pa"] = True
                c2pa_info["c2pa_fields"].append(key)
                c2pa_info["details"][key] = flat_metadata[key]

        # If we found AI indicators but no C2PA signature specifically,
        # check if there's enough evidence to suggest this is an AI image with credentials
        if (ai_indicators["ai_generated"] or
            (ai_indicators["creation_tool"] and ("openai" in str(ai_indicators["creation_tool"]).lower() or
                                               "dall-e" in str(ai_indicators["creation_tool"]).lower()))) and \
           ai_indicators["timestamp"]:
            c2pa_info["has_c2pa"] = True

            # Add signatures field if found
            if ai_indicators["signature"]:
                c2pa_info["c2pa_data"]["signatures"] = ["present"]

        return c2pa_info

    except subprocess.SubprocessError as e:
        return {
            "has_c2pa": False,
            "error": f"ExifTool error: {str(e)}"
        }
    except json.JSONDecodeError as e:
        return {
            "has_c2pa": False,
            "error": f"JSON parsing error: {str(e)}"
        }
    except Exception as e:
        return {
            "has_c2pa": False,
            "error": f"Unexpected error: {str(e)}"
        }

def check_simple_markers(image_path: str) -> Dict[str, Any]:
    """Check for simple markers that might indicate AI generation"""
    result = {
        "filename_indicators": False,
        "metadata_indicators": False,
        "potential_ai_indicators": []
    }

    # Check filename for AI-related terms
    filename = os.path.basename(image_path).lower()
    ai_terms = ["ai", "generated", "chatgpt", "midjourney", "dall-e", "stable diffusion",
                "gpt", "openai", "artificial"]

    for term in ai_terms:
        if term in filename:
            result["filename_indicators"] = True
            result["potential_ai_indicators"].append(f"Filename contains '{term}'")
            break

    # Check basic metadata
    try:
        # Use ExifTool for metadata
        exif_result = subprocess.run(
            ["exiftool", "-json", "-a", image_path],
            capture_output=True,
            check=True,
            text=True
        )

        metadata = json.loads(exif_result.stdout)[0]

        # Check for software/creator fields that might indicate AI
        software_fields = ["Software", "Creator", "Producer", "CreatorTool", "Generator"]
        ai_software_terms = ["ai", "gpt", "dall-e", "midjourney", "stable diffusion",
                           "neural", "gan", "diffusion", "generative"]

        for field in software_fields:
            if field in metadata:
                software_value = str(metadata[field]).lower()
                for term in ai_software_terms:
                    if term in software_value:
                        result["metadata_indicators"] = True
                        result["potential_ai_indicators"].append(
                            f"Metadata field '{field}' contains '{term}': {metadata[field]}"
                        )

        # Check for missing camera-specific metadata in photos
        if metadata.get("FileType") in ["JPEG", "HEIC", "TIFF"]:
            camera_fields = ["Make", "Model", "LensModel", "ExposureTime", "FNumber", "ISO"]
            missing_fields = [field for field in camera_fields if field not in metadata]

            if len(missing_fields) >= 5:  # If most camera fields are missing
                result["potential_ai_indicators"].append(
                    f"Missing typical camera metadata: {', '.join(missing_fields)}"
                )

    except Exception as e:
        result["metadata_error"] = str(e)

    return result

def generate_summary(results: Dict[str, Any]) -> str:
    """Generate a human-readable summary of the analysis results"""
    summary = []

    # C2PA summary
    if results.get("c2pa_check", {}).get("has_c2pa", False):
        summary.append("‚úÖ C2PA signature detected - this image contains content credentials")

        # Add details if available
        if "c2pa_data" in results["c2pa_check"]:
            c2pa_data = results["c2pa_check"]["c2pa_data"]
            if isinstance(c2pa_data, dict):
                # Initialize key indicators
                ai_generated = None
                creation_tool = None
                timestamp = None
                has_crypto_signature = False

                # Check for cryptographic signatures
                has_crypto_signature = (
                    "signatures" in c2pa_data or
                    "verification" in c2pa_data or
                    any("signature" in key.lower() for key in c2pa_data.keys())
                )

                # Extract relevant information from C2PA data
                if "assertions" in c2pa_data:
                    for assertion in c2pa_data["assertions"]:
                        label = assertion.get("label", "").lower()
                        data = assertion.get("data", {})

                        # Check for AI generation assertion
                        if label in ["generativeai", "ai", "generated", "generator"]:
                            if isinstance(data, dict) and "value" in data:
                                ai_generated = data["value"]
                            else:
                                ai_generated = str(data)

                        # Check for creation tool (OpenAI/DALL-E)
                        elif label in ["creator", "creationtool", "tool", "software"]:
                            if isinstance(data, dict) and "value" in data:
                                creation_tool = data["value"]
                            else:
                                creation_tool = str(data)

                        # Check for timestamp
                        elif label in ["timestamp", "creation", "creationdate", "datecreated"]:
                            if isinstance(data, dict) and "value" in data:
                                timestamp = data["value"]
                            else:
                                timestamp = str(data)

                # Add key indicators to summary
                if ai_generated:
                    summary.append(f"ü§ñ AI Generation: {ai_generated}")
                if creation_tool:
                    summary.append(f"üõ†Ô∏è Creation Tool: {creation_tool}")
                    if "openai" in str(creation_tool).lower() or "dall-e" in str(creation_tool).lower():
                        summary.append("‚≠ê OpenAI/DALL-E identified as the creation tool")
                if timestamp:
                    summary.append(f"üïí Creation Timestamp: {timestamp}")
                if has_crypto_signature:
                    summary.append("üîê Cryptographic signature present - data verification possible")
    else:
        summary.append("‚ùå No C2PA signature detected")

    # AI indicators
    ai_indicators = results.get("ai_indicators", {})
    potential_indicators = ai_indicators.get("potential_ai_indicators", [])

    if ai_indicators.get("filename_indicators") or ai_indicators.get("metadata_indicators"):
        summary.append("‚ö†Ô∏è Potential AI generation indicators found:")
        for indicator in potential_indicators:
            summary.append(f"  - {indicator}")
    else:
        if potential_indicators:
            summary.append("‚ö†Ô∏è Some metadata patterns consistent with AI generation:")
            for indicator in potential_indicators[:3]:  # Limit to top 3
                summary.append(f"  - {indicator}")
        else:
            summary.append("‚úì No obvious AI generation indicators in metadata")

    # File information
    file_info = [
        f"üìÑ Filename: {results['filename']}",
        f"üìä Dimensions: {results.get('image_info', {}).get('width', '?')}√ó{results.get('image_info', {}).get('height', '?')}",
        f"üíæ File size: {format_file_size(results['file_size'])}"
    ]

    return "\n".join(file_info + [""] + summary)

def format_file_size(size_bytes: int) -> str:
    """Format file size in human-readable format"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} TB"

def analyze_image(image_path: str) -> Dict[str, Any]:
    """Analyze image for C2PA signatures and AI generation indicators"""
    results = {
        "filename": os.path.basename(image_path),
        "file_size": os.path.getsize(image_path),
        "file_type": os.path.splitext(image_path)[1].lower(),
    }

    # Fall back to ExifTool as the primary method
    has_exiftool = install_exiftool()
    if has_exiftool:
        c2pa_results = check_c2pa_exiftool(image_path)
        results["c2pa_check"] = c2pa_results
    else:
        results["c2pa_check"] = {
            "has_c2pa": False,
            "error": "No tools available for C2PA detection"
        }

    # Check for other AI indicators
    results["ai_indicators"] = check_simple_markers(image_path)

    # Get basic image info
    try:
        with Image.open(image_path) as img:
            results["image_info"] = {
                "format": img.format,
                "mode": img.mode,
                "width": img.width,
                "height": img.height
            }
    except Exception as e:
        results["image_error"] = str(e)

    # Generate summary
    results["summary"] = generate_summary(results)

    return results

def display_results(results: Dict[str, Any]) -> None:
    """Display the results in a readable format"""
    print("\n" + "="*50)
    print("IMAGE ANALYSIS RESULTS")
    print("="*50)

    # Print summary
    print("\n" + results["summary"])

    # Print C2PA details if present
    c2pa_check = results.get("c2pa_check", {})
    if c2pa_check.get("has_c2pa", False):
        print("\n" + "-"*50)
        print("C2PA SIGNATURE DETAILS:")
        print("-"*50)

        # Extract key information from C2PA data
        if "c2pa_data" in c2pa_check and "assertions" in c2pa_check["c2pa_data"]:
            assertions = c2pa_check["c2pa_data"]["assertions"]
            for assertion in assertions:
                print(f"\nAssertion: {assertion.get('label', 'Unknown')}")
                if isinstance(assertion.get('data', {}), dict) and 'value' in assertion['data']:
                    print(f"Value: {assertion['data']['value']}")
                else:
                    print(f"Data: {assertion.get('data', 'No data')}")

    print("\n" + "="*50 + "\n")

# Main function to analyze an uploaded image
def analyze_uploaded_image():
    """Function to analyze uploaded images in Google Colab"""
    try:
        # Setup ExifTool
        has_exiftool = install_exiftool()
        if not has_exiftool:
            print("‚ö†Ô∏è ExifTool installation failed. Some functionality will be limited.")

        # Upload files
        print("Please upload an image file to analyze:")
        uploaded = files.upload()

        if not uploaded:
            print("No files were uploaded.")
            return

        # Analyze each uploaded file
        for filename in uploaded.keys():
            print(f"\nAnalyzing {filename}...")
            results = analyze_image(filename)

            # Display results
            display_results(results)

    except Exception as e:
        print(f"Error during analysis: {str(e)}")

# Execute the function
analyze_uploaded_image()

#!/usr/bin/env python3
"""
Improved C2PA Signature Detector for Images
-------------------------------------------
This script checks whether an image file contains genuine C2PA (Coalition for Content Provenance and Authenticity)
signatures, with improved accuracy to avoid false positives.
"""

import os
import sys
import subprocess
import json
import tempfile
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, Union
import base64
import re
import io
import warnings

try:
    from PIL import Image
    import numpy as np
    from google.colab import files
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "Pillow", "numpy"])
    from PIL import Image
    import numpy as np
    try:
        from google.colab import files
    except ImportError:
        print("Not running in Google Colab environment")

# Install exiftool if not present
def install_exiftool():
    """Install ExifTool if not already present"""
    try:
        # Check if ExifTool is already available
        subprocess.run(["exiftool", "-ver"], capture_output=True, check=True)
        return True
    except (subprocess.SubprocessError, FileNotFoundError):
        # Check if we're in Google Colab
        try:
            import google.colab
            in_colab = True
        except ImportError:
            in_colab = False

        if in_colab:
            print("Installing ExifTool in Colab environment...")
            try:
                subprocess.check_call(["apt-get", "update", "-qq"])
                subprocess.check_call(["apt-get", "install", "-y", "-qq", "libimage-exiftool-perl"])
                print("ExifTool installed successfully.")
                return True
            except subprocess.SubprocessError as e:
                print(f"Failed to install ExifTool: {e}")
                return False
        else:
            print("ExifTool not found. Please install ExifTool.")
            return False

def check_c2pa_exiftool(image_path: str) -> Dict[str, Any]:
    """
    Check for genuine C2PA using ExifTool with improved accuracy
    to avoid false positives from regular camera metadata
    """
    try:
        # Run exiftool with JSON output, accessing all tags
        result = subprocess.run(
            ["exiftool", "-json", "-a", "-u", "-G3", image_path],
            capture_output=True,
            check=True,
            text=True
        )

        # Parse the JSON output
        metadata = json.loads(result.stdout)[0]

        # Initialize result
        c2pa_info = {
            "has_c2pa": False,
            "c2pa_fields": [],
            "details": {},
            "c2pa_data": {"assertions": []}
        }

        # Strong C2PA indicators - these strings are highly specific to C2PA
        strong_c2pa_indicators = [
            "C2PA", "CAI", "ContentCredentials", "c2pa:assertion",
            "ContentAuthenticityInitiative", "adobe:certification", "stds.schema-org:claimReview"
        ]

        # Specific AI model/tool indicators
        ai_model_indicators = [
            "DALL-E", "Midjourney", "Stable Diffusion", "Firefly",
            "GAN", "Neural", "Diffusion", "GPT", "generativeai:true"
        ]

        # Flatten metadata for easier searching
        flat_metadata = {}

        def flatten_dict(d, parent_key=''):
            for k, v in d.items():
                new_key = f"{parent_key}.{k}" if parent_key else k
                if isinstance(v, dict):
                    flatten_dict(v, new_key)
                else:
                    flat_metadata[new_key] = v

        flatten_dict(metadata)

        # Check for specific XMP namespaces associated with C2PA
        xmp_namespaces = [k for k in flat_metadata.keys() if 'XMP:' in k or 'XMP-' in k]
        found_c2pa_ns = False

        for key in xmp_namespaces:
            value = str(flat_metadata[key]).lower()
            # Look for C2PA namespaces in XMP data
            if any(c2pa_term.lower() in value for c2pa_term in strong_c2pa_indicators):
                found_c2pa_ns = True
                c2pa_info["c2pa_fields"].append(key)
                c2pa_info["details"][key] = flat_metadata[key]

        # Look for strong C2PA indicators in any metadata field
        found_strong_indicator = False
        for key, value in flat_metadata.items():
            str_value = str(value).lower()
            str_key = str(key).lower()

            # Check for strong C2PA indicators
            for indicator in strong_c2pa_indicators:
                if indicator.lower() in str_key or indicator.lower() in str_value:
                    found_strong_indicator = True
                    c2pa_info["c2pa_fields"].append(key)
                    c2pa_info["details"][key] = value
                    break

            # Check for AI model/tool indicators
            for ai_indicator in ai_model_indicators:
                if ai_indicator.lower() in str_key or ai_indicator.lower() in str_value:
                    # Add this as an assertion
                    c2pa_info["c2pa_data"]["assertions"].append({
                        "label": "AI Model/Tool",
                        "data": {"value": value}
                    })
                    break

        # Check for JUMBF blocks which often contain C2PA
        jumbf_keys = [k for k in flat_metadata.keys() if 'JUMBF' in k]
        found_jumbf = len(jumbf_keys) > 0

        # Look for specific Software fields that might indicate AI generation
        ai_software = False
        if 'Software' in metadata:
            software = str(metadata['Software']).lower()
            ai_software_terms = ["openai", "dall-e", "midjourney", "stability", "firefly"]
            if any(term in software for term in ai_software_terms):
                ai_software = True
                c2pa_info["c2pa_data"]["assertions"].append({
                    "label": "AI Software",
                    "data": {"value": metadata['Software']}
                })

        # Only mark as having C2PA if we have strong indicators
        # This helps avoid false positives from regular camera metadata
        if found_strong_indicator or found_c2pa_ns or found_jumbf and ai_software:
            c2pa_info["has_c2pa"] = True

        # Additional checks for common false positives
        if 'Make' in metadata and ('Apple' in str(metadata['Make']) or 'iPhone' in str(metadata['Make'])):
            # iPhone photos often have complex metadata that can trigger false positives
            if not found_strong_indicator and not found_c2pa_ns:
                c2pa_info["has_c2pa"] = False

        return c2pa_info

    except subprocess.SubprocessError as e:
        return {
            "has_c2pa": False,
            "error": f"ExifTool error: {str(e)}"
        }
    except json.JSONDecodeError as e:
        return {
            "has_c2pa": False,
            "error": f"JSON parsing error: {str(e)}"
        }
    except Exception as e:
        return {
            "has_c2pa": False,
            "error": f"Unexpected error: {str(e)}"
        }

def check_ai_generation_indicators(image_path: str) -> Dict[str, Any]:
    """Check for indicators that might suggest AI generation,
    but aren't necessarily C2PA signatures"""
    result = {
        "filename_indicators": False,
        "metadata_indicators": False,
        "potential_ai_indicators": []
    }

    # Check filename for AI-related terms
    filename = os.path.basename(image_path).lower()
    ai_terms = ["ai", "generated", "chatgpt", "midjourney", "dall-e", "stable diffusion",
                "gpt", "openai", "artificial"]

    for term in ai_terms:
        if term in filename:
            result["filename_indicators"] = True
            result["potential_ai_indicators"].append(f"Filename contains '{term}'")
            break

    # Check basic metadata
    try:
        # Use ExifTool for metadata
        exif_result = subprocess.run(
            ["exiftool", "-json", "-a", image_path],
            capture_output=True,
            check=True,
            text=True
        )

        metadata = json.loads(exif_result.stdout)[0]

        # Check for software/creator fields that might indicate AI
        software_fields = ["Software", "Creator", "Producer", "CreatorTool", "Generator"]
        ai_software_terms = ["ai", "gpt", "dall-e", "midjourney", "stable diffusion",
                           "neural", "gan", "diffusion", "generative"]

        for field in software_fields:
            if field in metadata:
                software_value = str(metadata[field]).lower()
                for term in ai_software_terms:
                    if term in software_value:
                        result["metadata_indicators"] = True
                        result["potential_ai_indicators"].append(
                            f"Metadata field '{field}' contains '{term}': {metadata[field]}"
                        )

        # Check for specific characteristics of AI-generated images
        if metadata.get("FileType") in ["JPEG", "PNG"]:
            # Check for missing camera-specific metadata in photos that claim to be photos
            # Only significant if paired with other indicators
            if "JPEGQualityEstimate" in metadata and metadata.get("Make") is None and metadata.get("Model") is None:
                # JPEG with no camera info is suspicious only with other indicators
                if result["filename_indicators"] or result["metadata_indicators"]:
                    result["potential_ai_indicators"].append(
                        "Image lacks camera metadata but has other AI indicators"
                    )

    except Exception as e:
        result["metadata_error"] = str(e)

    return result

def generate_summary(results: Dict[str, Any]) -> str:
    """Generate a human-readable summary of the analysis results"""
    summary = []

    # File information
    file_info = [
        f"üìÑ Filename: {results['filename']}",
        f"üìä Dimensions: {results.get('image_info', {}).get('width', '?')}√ó{results.get('image_info', {}).get('height', '?')}",
        f"üíæ File size: {format_file_size(results['file_size'])}"
    ]

    # C2PA summary
    if results.get("c2pa_check", {}).get("has_c2pa", False):
        summary.append("‚úÖ C2PA signature detected - this image contains content credentials")

        # Add details about assertions if available
        assertions = results.get("c2pa_check", {}).get("c2pa_data", {}).get("assertions", [])
        if assertions:
            ai_related_assertions = [a for a in assertions if any(
                term in str(a.get("label", "")).lower() for term in
                ["ai", "model", "tool", "software", "generate"]
            )]

            if ai_related_assertions:
                for assertion in ai_related_assertions[:3]:  # Limit to top 3
                    label = assertion.get("label", "")
                    value = assertion.get("data", {}).get("value", "Unknown")
                    summary.append(f"ü§ñ {label}: {value}")
    else:
        summary.append("‚ùå No C2PA signature detected")

    # AI indicators
    ai_indicators = results.get("ai_indicators", {})
    potential_indicators = ai_indicators.get("potential_ai_indicators", [])

    if ai_indicators.get("filename_indicators") and ai_indicators.get("metadata_indicators"):
        summary.append("‚ö†Ô∏è Multiple AI generation indicators found:")
        for indicator in potential_indicators:
            summary.append(f"  - {indicator}")
    elif ai_indicators.get("filename_indicators") or ai_indicators.get("metadata_indicators"):
        summary.append("‚ÑπÔ∏è Some potential AI generation indicators:")
        for indicator in potential_indicators:
            summary.append(f"  - {indicator}")
    else:
        summary.append("‚úì No AI generation indicators found in metadata")

    # Camera information if available
    has_camera_info = False
    camera_info = []

    if "exif_data" in results:
        exif = results["exif_data"]
        if "Make" in exif and "Model" in exif:
            has_camera_info = True
            camera_info.append(f"üì∑ Camera: {exif['Make']} {exif['Model']}")

        if "DateTimeOriginal" in exif:
            has_camera_info = True
            camera_info.append(f"üìÖ Date Taken: {exif['DateTimeOriginal']}")

    if has_camera_info:
        summary.append("üì∏ Photo taken with a camera:")
        summary.extend([f"  {info}" for info in camera_info])

    return "\n".join(file_info + [""] + summary)

def format_file_size(size_bytes: int) -> str:
    """Format file size in human-readable format"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} TB"

def extract_exif_data(image_path: str) -> Dict[str, Any]:
    """Extract clean EXIF data for analysis"""
    try:
        # Run exiftool focusing on common EXIF fields
        result = subprocess.run(
            ["exiftool", "-json", "-Make", "-Model", "-Software", "-DateTimeOriginal",
             "-ExposureTime", "-FNumber", "-ISO", "-LensModel", image_path],
            capture_output=True,
            check=True,
            text=True
        )

        metadata = json.loads(result.stdout)[0]
        return metadata
    except:
        return {}

def analyze_image(image_path: str) -> Dict[str, Any]:
    """Analyze image for C2PA signatures and AI generation indicators with improved accuracy"""
    results = {
        "filename": os.path.basename(image_path),
        "file_size": os.path.getsize(image_path),
        "file_type": os.path.splitext(image_path)[1].lower(),
    }

    # Extract basic EXIF data
    results["exif_data"] = extract_exif_data(image_path)

    # Check for C2PA signatures with improved accuracy
    has_exiftool = install_exiftool()
    if has_exiftool:
        c2pa_results = check_c2pa_exiftool(image_path)
        results["c2pa_check"] = c2pa_results
    else:
        results["c2pa_check"] = {
            "has_c2pa": False,
            "error": "ExifTool not available for C2PA detection"
        }

    # Check for AI generation indicators
    results["ai_indicators"] = check_ai_generation_indicators(image_path)

    # Get basic image info
    try:
        with Image.open(image_path) as img:
            results["image_info"] = {
                "format": img.format,
                "mode": img.mode,
                "width": img.width,
                "height": img.height
            }
    except Exception as e:
        results["image_error"] = str(e)

    # Generate summary
    results["summary"] = generate_summary(results)

    return results

def display_results(results: Dict[str, Any]) -> None:
    """Display the results in a clean, readable format"""
    print("\n" + "="*50)
    print("IMAGE ANALYSIS RESULTS")
    print("="*50 + "\n")

    # Print summary
    print(results["summary"])

    # Print C2PA details if present (and confirmed)
    c2pa_check = results.get("c2pa_check", {})
    if c2pa_check.get("has_c2pa", False):
        print("\n" + "-"*50)
        print("C2PA DETAILS (VERIFIED CONTENT CREDENTIALS):")
        print("-"*50)

        # Only show meaningful assertions, not all metadata
        if "c2pa_data" in c2pa_check and "assertions" in c2pa_check["c2pa_data"]:
            assertions = c2pa_check["c2pa_data"]["assertions"]
            if assertions:
                # Group related assertions
                for assertion in assertions:
                    label = assertion.get("label", "Unknown")
                    if isinstance(assertion.get('data', {}), dict) and 'value' in assertion['data']:
                        print(f"‚Ä¢ {label}: {assertion['data']['value']}")
                    else:
                        data_str = str(assertion.get('data', 'No data'))
                        # Skip binary data dumps
                        if not "binary data" in data_str.lower():
                            print(f"‚Ä¢ {label}: {data_str}")
            else:
                print("No detailed assertion data available")

    # Print EXIF camera data if present
    if "exif_data" in results and results["exif_data"]:
        exif = results["exif_data"]
        if any(key in exif for key in ["Make", "Model", "DateTimeOriginal"]):
            print("\n" + "-"*50)
            print("CAMERA METADATA:")
            print("-"*50)

            # Show camera make/model
            if "Make" in exif or "Model" in exif:
                make = exif.get("Make", "")
                model = exif.get("Model", "")
                print(f"‚Ä¢ Camera: {make} {model}".strip())

            # Show date/time
            if "DateTimeOriginal" in exif:
                print(f"‚Ä¢ Date Taken: {exif['DateTimeOriginal']}")

            # Show exposure settings
            exposure_settings = []
            if "ExposureTime" in exif:
                exposure_settings.append(f"Exposure: {exif['ExposureTime']}")
            if "FNumber" in exif:
                exposure_settings.append(f"F-Stop: {exif['FNumber']}")
            if "ISO" in exif:
                exposure_settings.append(f"ISO: {exif['ISO']}")

            if exposure_settings:
                print(f"‚Ä¢ Settings: {', '.join(exposure_settings)}")

            # Show lens info
            if "LensModel" in exif:
                print(f"‚Ä¢ Lens: {exif['LensModel']}")

    print("\n" + "="*50)
    print("CONCLUSION:")
    print("="*50)

    if c2pa_check.get("has_c2pa", False):
        print("This image contains verified content credentials (C2PA).")
        print("It likely includes provenance information about its creation.")
    elif results["ai_indicators"].get("filename_indicators") and results["ai_indicators"].get("metadata_indicators"):
        print("This image has strong indicators suggesting AI generation,")
        print("but does not contain formal content credentials (C2PA).")
    elif "exif_data" in results and ("Make" in results["exif_data"] or "Model" in results["exif_data"]):
        print("This appears to be a genuine photograph taken with a camera.")
        print("No content credentials or AI indicators were found.")
    else:
        print("This image does not contain formal content credentials (C2PA).")
        print("No strong indicators of AI generation were found in the metadata.")

    print("\n")

# Main function to analyze an uploaded image
def analyze_uploaded_image():
    """Function to analyze uploaded images in Google Colab"""
    try:
        # Setup ExifTool
        has_exiftool = install_exiftool()
        if not has_exiftool:
            print("‚ö†Ô∏è ExifTool installation failed. Analysis capabilities will be limited.")
            return

        # Upload files
        print("Please upload an image file to analyze:")
        uploaded = files.upload()

        if not uploaded:
            print("No files were uploaded.")
            return

        # Analyze each uploaded file
        for filename in uploaded.keys():
            print(f"\nAnalyzing {filename}...")
            results = analyze_image(filename)

            # Display results
            display_results(results)

    except Exception as e:
        print(f"Error during analysis: {str(e)}")

# Execute the function
analyze_uploaded_image()

